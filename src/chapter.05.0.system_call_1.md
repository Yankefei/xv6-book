# 5.1 system call 介绍

在xv6操作系统中，system call 系统调用是基于Traps来实现的, 这里先简单介绍 system call 的一些设计，之后着重介绍traps

## 1. System call 相关

There are three kinds of event which cause the CPU to set aside ordinary execution of instructions  and force a transfer of control to special code that handles the event. One situation is a system  call, **when a user program executes the ecall instruction to ask the kernel to do something for it**. Another situation is an *exception*: an instruction (user or kernel) does something illegal, such as  divide by zero or use an invalid virtual address. The third situation is a device *interrupt*, when a  device signals that it needs attention, for example when the disk hardware finishes a read or write  request.

risc-v的系统调用，由ecall指令触发，开始执行trap部分的逻辑，system call 只是trap机制的一个功能。trap下面详细展开

系统调用的返回值，目前在用户空间中，会返回给 trapframe的a0，最终会设置给a0寄存器，这个也就是最终返回给用户空间的返回值

> When sys_exec returns, syscall records its return value in p->trapframe->a0. This will  cause the original user-space call to exec() to return that value, since the **C calling convention on RISC-V places return values in a0.**

代码中的系统调用，均由perl 脚本来展开为汇编指令，并参与编译和链接

```perl
print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";
    print " li a7, SYS_${name}\n";
    print " ecall\n";
    print " ret\n";
}
```

ref: user/usys.pl

