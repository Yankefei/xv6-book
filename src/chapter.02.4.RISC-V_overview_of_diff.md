# 2.4 RISC-V 架构操作系统需要留意的特征：

## 1. 和一般操作系统的地址空间的差异点：

The danger is that a user could construct an ELF binary with a ph.vaddr that points to a user-chosen address, and ph.memsz large enough that the sum overflows to 0x1000, which will look like a valid value. In an older version of xv6 in which the user address space also contained the kernel (but not readable/writable in user mode), the user could choose an address that corresponded to kernel memory and would thus copy data from the ELF binary into the kernel. 

In the RISC-V version of xv6 this cannot happen, because the kernel has its own separate page table; loadse loads into the process’s page table, not in the kernel’s page table.

xv6的第一个很大的不同，在于用户空间和内核空间是完全独立的，由不同的page table 来加载。不像linux系统一样，两者在同一个地址空间内。



## 2. 关于 trap时的差别

A major constraint（约束） on the design of xv6’s trap handling is the fact that **the RISC-V hardware does not switch page tables when it forces a trap.** This means that the trap handler address in stvec must have a valid mapping **in the user page table**, since that’s the page table in force when the trap handling code starts executing. Furthermore, xv6’s trap handling code needs to switch to the kernel page table; in order to be able to continue executing after that switch, the kernel page table must also have a mapping for the handler pointed to by stvec. 

Xv6 satisfies these requirements using a *trampoline* page. The trampoline page contains uservec, the xv6 trap handling code that stvec points to. The trampoline page is mapped in every process’s page table at address TRAMPOLINE, which is at the top of the virtual address space so that it will be above memory that programs use for themselves. The trampoline page is also mapped at address TRAMPOLINE in the kernel page table. See Figure 2.3 and Figure 3.3. Because the trampoline page is mapped in the user page table, without the PTE_U flag, traps can start executing there in supervisor mode. **Because the trampoline page is mapped at the same address in the kernel address space, the trap handler can continue to execute after it switches to the kernel page table.**

trap时，RISC-V 硬件不支持在陷入一个trap时，切换 page table。也就是当内核执行trap handle时，stvec需要有一个可用的用户页表的映射。

而且后面因为trampoline页面的地址在内核空间和用户空间是一样的。trap handle 可以在切换page table时，照常执行。



## 3. 启停interrupts的差异点

Xv6 sets a CPU’s stvec to kernelvec when that CPU enters the kernel from user space; you can see this in usertrap (kernel/trap.c:29). There’s a window of time when the kernel has started executing but stvec is still set to uservec, and it’s crucial(关键的) that no device interrupt occur during that window. **Luckily the RISC-V always disables interrupts when it starts to take a trap, and xv6 doesn’t enable them again until after it sets stvec**.

存在一个时间段，当内核已经在执行时，stvec仍然设置的 uservec。所以在这个间隙，没有device interrupt被触发是很重要的。不过 RISC-V总是在执行trap时，禁止interrupt，而且xv6也是只到重新设置了stvec后，才允许interrupt的。

> 注：经过测试发现，确实在从 usertrapret 返回时，重新进入 uservec后，RISC-V会将 SSTATUS_SIE 这个字段去掉

```C
//
// handle an interrupt, exception, or system call from user space.
// called from trampoline.S
//
void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  // 设置了kernel的trap handle，之后才执行 intr_on
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p->trapframe->epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(killed(p))
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sepc, scause, and sstatus,
    // so enable only now that we're done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    setkilled(p);
  }

  if(killed(p))
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
```



## 4. 关于定时器中断

A timer interrupt can occur at any point when user or kernel code is executing; there’s no way for the kernel to disable timer interrupts during critical(关键的) operations. Thus the timer interrupt handler must do its job in a way guaranteed n**ot to disturb interrupted kernel code**. **The basic strategy is for the handler to ask the RISC-V to raise a “software interrupt” and immediately return.** The RISC-V delivers software interrupts to the kernel with the ordinary trap mechanism, and allows the kernel to disable them. The code to handle the software interrupt generated by a timer interrupt can be seen in devintr (kernel/trap.c:205). **The machine-mode timer interrupt handler is timervec (kernel/kernelvec.S:95). It saves a few registers in the scratch area prepared by start, tells the CLINT when to generate the next timer interrupt, asks the RISC-V to raise a software interrupt, restores registers, and returns.** There’s no C code in the timer interrupt handler.

相当于定时器的中断，是在machine-mode下的，为了触发一个软件中断，它在timervec里面做了一些操作，让CLINT来定时去触发一次，进而创造一个RISC-V的软件中断。



## 5. 关于获取CPU current hartid的值

It would be more convenient if xv6 could ask the RISC-V hardware for the current hartid whenever needed, but RISC-V allows that only in machine mode, not in supervisor mode.

RISC-V只允许在 machine下获取，而不是 supervisor 模式下，所以需要先放在一个通用点的寄存器中。

```C
// which hart (core) is this?
static inline uint64
r_mhartid()
{
  uint64 x;
  asm volatile("csrr %0, mhartid" : "=r" (x) );
  return x;
}


static inline void 
w_tp(uint64 x)
{
  asm volatile("mv tp, %0" : : "r" (x));
}
  

// keep each CPU's hartid in its tp register, for cpuid().
int id = r_mhartid();
w_tp(id);
```