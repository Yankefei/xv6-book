# 4.2 risc-v File Structure

## 1. elf 文件结构

当涉及 RISC-V 可执行文件的结构时，一般会遵循 ELF（Executable and Linkable Format）文件格式规范。下面是一个典型的 RISC-V 可执行文件的结构示意图：

```Plain
----------------------------------------------------------------
|                       ELF Header                              |
----------------------------------------------------------------
|                   Program Header Table                        |
----------------------------------------------------------------
|                Section Header Table (可选)                    |
----------------------------------------------------------------
|                   Text (Code) Segment                         |
|--------------------------------------------------------------|
|                   Data Segment                               |
|--------------------------------------------------------------|
|                   BSS Segment                                |
|--------------------------------------------------------------|
|                   Symbol Table                                |
|--------------------------------------------------------------|
|                   Debug Information                           |
----------------------------------------------------------------
```





上述示意图展示了一个典型的 RISC-V 可执行文件的结构，包括以下部分：

1. ELF 头部（ELF Header）：包含了描述整个文件结构的信息，如文件类型、目标体系结构、入口点地址等。
2. 程序头表（Program Header Table）：描述了各个程序段在文件中的位置和大小等信息。
3. 节头表（Section Header Table）：可选部分，包含了各个节（Sections）的信息，如代码段、数据段等。
4. 代码段（Text Segment）：存储程序的可执行指令。
5. 数据段（Data Segment）：存储程序的全局变量、静态变量和初始化的常量。
6. BSS 段（Block Started by Symbol Segment）：存储未初始化的全局变量和静态变量。
7. 符号表（Symbol Table）：存储程序中定义和引用的符号及其相关信息。
8. 调试信息（Debug Information）：存储与调试相关的信息，如源代码行号、变量名等。

以上是一个简化的 RISC-V 可执行文件结构示意图，实际的文件结构可能会更加复杂，并且会根据具体的应用程序和编译器设置而有所不同。ELF 文件格式为描述可执行文件的组织结构提供了一个通用的标准，可以帮助操作系统正确加载和执行程序。





## 2. risc-v elf 头部

 和  /kernel/elf.h 里面定义的是一致的

```C
#include <stdint.h>

#define EI_NIDENT 16

typedef struct {
    uint8_t e_ident[EI_NIDENT]; /* ELF 标识符数组 */
    uint16_t e_type;            /* 目标文件类型 */
    uint16_t e_machine;         /* 目标体系结构 */
    uint32_t e_version;         /* 目标文件版本 */
    uint64_t e_entry;           /* 程序入口点地址 */
    uint64_t e_phoff;           /* 程序头表偏移量 */
    uint64_t e_shoff;           /* 节区头表偏移量 */
    uint32_t e_flags;           /* 处理器特定标志 */
    uint16_t e_ehsize;          /* ELF 头部大小 */
    uint16_t e_phentsize;       /* 程序头表项大小 */
    uint16_t e_phnum;           /* 程序头表项数量 */   // 通过 e_phnum 和 e_phoff 来读取Phdr
    uint16_t e_shentsize;       /* 节区头表项大小 */
    uint16_t e_shnum;           /* 节区头表项数量 */
    uint16_t e_shstrndx;        /* 节区字符串表索引 */
} Elf64_Ehdr;
```



## 3. Program Header Table（程序头表）

和  /kernel/elf.h 里面定义的是一致的

用于描述 ELF 文件中的程序头表（Program Header Table）中的每个程序头（Program Header）条目的格式和信息。

程序头表包含了一系列程序头条目，每个程序头条目描述了一个程序段（Program Segment）在文件中的位置、大小、内存对齐等信息。通过解析程序头表中的各个程序头条目，操作系统可以正确加载可执行文件到内存中，并为程序分配适当的资源。

```C
#include <stdint.h>

typedef struct {
    uint32_t p_type;     /* 程序段类型 */
    uint32_t p_flags;    /* 程序段标志 */
    uint64_t p_offset;   /* 程序段在文件中的偏移量 */
    uint64_t p_vaddr;    /* 程序段的虚拟地址 */
    uint64_t p_paddr;    /* 程序段的物理地址（仅用于系统级别的程序） */
    uint64_t p_filesz;   /* 程序段在文件中的大小 */
    uint64_t p_memsz;    /* 程序段在内存中的大小 */
    uint64_t p_align;    /* 程序段的对齐方式 */
} Elf64_Phdr;
```

其中，`p_type` 表示程序头类型，`p_offset` 表示程序段在文件中的偏移量，`p_vaddr` 和 `p_paddr` 分别表示程序段在内存中的虚拟地址和物理地址，`p_filesz` 和 `p_memsz` 分别表示程序段在文件中和内存中的大小，`p_flags` 表示标志位，`p_align` 表示对齐方式。

通过解析 `Elf64_Phdr` 结构体中的字段，操作系统可以了解每个程序段在文件和内存中的布局以及相应的权限和对齐方式，从而正确加载和执行 ELF 可执行文件。

`p_filesz` 和 `p_memsz` 有可能不一样大，前者小于后者，这种情况通常发生在一个段有未初始化的数据或需要在内存中进行初始化时







### 1. p_type类型定义

在 ELF64 文件格式中，`Elf64_Phdr` 结构体中的 `p_type` 字段表示程序头表条目的类型，它指定了这个程序头描述的是什么样的段。一般来说，对于不同类型的段，`p_type` 可能会取不同的数值。下面是一些常见的 `p_type` 类型：

1. `PT_NULL` (0)：表示这个段表项是空的，没有实际意义。
2. `PT_LOAD` (1)：表示这个段应被加载到内存中。
3. `PT_DYNAMIC` (2)：表示动态链接信息。
4. `PT_INTERP` (3)：表示解释器的路径名，用于动态链接。
5. `PT_NOTE` (4)：包含一些辅助信息。
6. `PT_SHLIB` (5)：已废弃，表示保留的段类型。
7. `PT_PHDR` (6)：表示包含程序头表本身的段。
8. `PT_TLS` (7)：表示线程局部存储相关的信息。
9. `PT_GNU_EH_FRAME` (0x6474e550)：GNU 扩展，表示异常处理框架信息。
10. `PT_GNU_STACK` (0x6474e551)：GNU 扩展，标识栈属性（可执行/不可执行）。

这里列举的是一些常见的 `p_type` 类型，实际上还有其他类型用于描述更多特定的段。在解析 ELF 文件时，可以根据 `p_type` 字段的取值来判断程序头表中描述的段的类型，从而正确处理和加载各个段。



### 2. p_flags 类型：

对于`Elf64_Phdr`的`p_flags`字段，标志包括：

1. PF_X (Execute): 可执行标志。
   1. 值通常定义为 `0x1`。
   2. 当此标志被设置时，表示这部分内存区域可以被执行。
2. PF_W (Write): 可写标志。
   1. 值通常定义为 `0x2`。
   2. 当此标志被设置时，表示这部分内存区域可以被写入。
3. PF_R (Read): 可读标志。
   1. 值通常定义为 `0x4`。
   2. 当此标志被设置时，表示这部分内存区域可以被读取。

组合使用

这些标志可以单独使用或组合使用来提供不同的内存访问权限。例如：

- `PF_R | PF_W`: 表示段是可读写的。
- `PF_R | PF_X`: 表示段是可读且可执行的。
- `PF_R | PF_W | PF_X`: 表示段是可读、可写、可执行的。